import { supabase } from '@/integrations/supabase/client';
import { config } from '@/config/runtime';

export type SubscriptionMode = 'auto' | 'manual';

export type SourceSubscription = {
  id: string;
  source_type: string;
  source_channel_id: string;
  source_channel_url: string | null;
  source_channel_title: string | null;
  source_channel_avatar_url?: string | null;
  mode: SubscriptionMode;
  is_active: boolean;
  last_polled_at: string | null;
  last_seen_published_at: string | null;
  last_seen_video_id: string | null;
  last_sync_error: string | null;
  created_at: string;
  updated_at: string;
};

export type SubscriptionRefreshCandidate = {
  subscription_id: string;
  source_channel_id: string;
  source_channel_title: string | null;
  source_channel_url: string | null;
  video_id: string;
  video_url: string;
  title: string;
  published_at: string | null;
  thumbnail_url: string | null;
};

type ApiEnvelope<T> = {
  ok: boolean;
  error_code: string | null;
  message: string;
  data: T;
};

class ApiRequestError extends Error {
  status: number;
  errorCode: string | null;
  data: unknown;

  constructor(status: number, message: string, errorCode: string | null = null, data: unknown = null) {
    super(message);
    this.status = status;
    this.errorCode = errorCode;
    this.data = data;
  }
}

function getApiBase() {
  if (!config.agenticBackendUrl) return null;
  return `${config.agenticBackendUrl.replace(/\/$/, '')}/api`;
}

async function getAuthHeader(): Promise<Record<string, string>> {
  const { data } = await supabase.auth.getSession();
  const token = data.session?.access_token;
  if (!token) throw new ApiRequestError(401, 'Sign in required.', 'AUTH_REQUIRED');
  return { Authorization: `Bearer ${token}` };
}

async function apiRequest<T>(path: string, init?: RequestInit): Promise<ApiEnvelope<T>> {
  const base = getApiBase();
  if (!base) {
    throw new ApiRequestError(503, 'Backend API is not configured.', 'API_NOT_CONFIGURED');
  }

  const authHeader = await getAuthHeader();
  const response = await fetch(`${base}${path}`, {
    ...init,
    headers: {
      'Content-Type': 'application/json',
      ...authHeader,
      ...(init?.headers || {}),
    },
  });

  const json = (await response.json().catch(() => null)) as ApiEnvelope<T> | null;
  if (!response.ok || !json) {
    throw new ApiRequestError(
      response.status,
      json?.message || `Request failed (${response.status})`,
      json?.error_code || null,
      json?.data ?? null,
    );
  }
  if (!json.ok) {
    throw new ApiRequestError(
      response.status,
      json.message || 'Request failed.',
      json.error_code || null,
      json.data ?? null,
    );
  }
  return json;
}

export async function listSourceSubscriptions() {
  const response = await apiRequest<SourceSubscription[]>('/source-subscriptions', { method: 'GET' });
  return response.data;
}

export async function createSourceSubscription(input: { channelInput: string; mode?: SubscriptionMode }) {
  const response = await apiRequest<{
    subscription: SourceSubscription;
    sync: {
      processed: number;
      inserted: number;
      skipped: number;
      newestVideoId: string | null;
      newestPublishedAt: string | null;
      channelTitle: string | null;
    } | null;
  }>('/source-subscriptions', {
    method: 'POST',
    body: JSON.stringify({
      channel_input: input.channelInput,
      mode: input.mode || 'auto',
    }),
  });

  return response.data;
}

export async function updateSourceSubscription(input: { id: string; mode?: SubscriptionMode; isActive?: boolean }) {
  const response = await apiRequest<SourceSubscription>(`/source-subscriptions/${input.id}`, {
    method: 'PATCH',
    body: JSON.stringify({
      mode: input.mode,
      is_active: input.isActive,
    }),
  });
  return response.data;
}

export async function deactivateSourceSubscription(id: string) {
  const response = await apiRequest<{ id: string }>(`/source-subscriptions/${id}`, { method: 'DELETE' });
  return response.data;
}

export async function deactivateSourceSubscriptionByChannelId(channelId: string) {
  const normalized = String(channelId || '').trim();
  if (!normalized) {
    throw new ApiRequestError(400, 'Channel id is required.', 'INVALID_CHANNEL_ID');
  }

  const subscriptions = await listSourceSubscriptions();
  const match = subscriptions.find((row) => row.source_channel_id === normalized && row.is_active);
  if (!match) {
    throw new ApiRequestError(404, 'Subscription not found for this channel.', 'NOT_FOUND');
  }

  return deactivateSourceSubscription(match.id);
}

export async function syncSourceSubscription(id: string) {
  const response = await apiRequest<{
    job_id: string;
    processed: number;
    inserted: number;
    skipped: number;
    newestVideoId: string | null;
    newestPublishedAt: string | null;
    channelTitle: string | null;
  }>(`/source-subscriptions/${id}/sync`, { method: 'POST', body: JSON.stringify({}) });
  return response.data;
}

export async function scanSubscriptionRefreshCandidates(input?: {
  maxPerSubscription?: number;
  maxTotal?: number;
}) {
  const response = await apiRequest<{
    subscriptions_total: number;
    candidates_total: number;
    candidates: SubscriptionRefreshCandidate[];
    scan_errors: Array<{ subscription_id: string; error: string }>;
    cooldown_filtered?: number;
  }>('/source-subscriptions/refresh-scan', {
    method: 'POST',
    body: JSON.stringify({
      max_per_subscription: input?.maxPerSubscription,
      max_total: input?.maxTotal,
    }),
  });
  return response.data;
}

export type IngestionJobStatus = 'queued' | 'running' | 'succeeded' | 'failed';

export type IngestionJob = {
  job_id: string;
  trigger: string;
  scope: string;
  status: IngestionJobStatus;
  started_at: string | null;
  finished_at: string | null;
  processed_count: number;
  inserted_count: number;
  skipped_count: number;
  error_code: string | null;
  error_message: string | null;
  created_at?: string | null;
  updated_at?: string | null;
};

export async function getIngestionJob(jobId: string) {
  const response = await apiRequest<IngestionJob>(`/ingestion/jobs/${jobId}`, {
    method: 'GET',
  });
  return response.data;
}

export async function getLatestMyIngestionJob(scope = 'manual_refresh_selection') {
  const query = new URLSearchParams();
  if (scope) query.set('scope', scope);
  const response = await apiRequest<IngestionJob | null>(`/ingestion/jobs/latest-mine?${query.toString()}`, {
    method: 'GET',
  });
  return response.data;
}

export async function generateSubscriptionRefreshBlueprints(input: {
  items: SubscriptionRefreshCandidate[];
}) {
  const response = await apiRequest<{
    job_id: string;
    queued_count: number;
  }>('/source-subscriptions/refresh-generate', {
    method: 'POST',
    body: JSON.stringify({
      items: input.items,
    }),
  });
  return response.data;
}

export async function acceptMyFeedPendingItem(id: string) {
  const response = await apiRequest<{
    user_feed_item_id: string;
    blueprint_id: string;
    state: string;
  }>(`/my-feed/items/${id}/accept`, { method: 'POST', body: JSON.stringify({}) });
  return response.data;
}

export async function skipMyFeedPendingItem(id: string) {
  const response = await apiRequest<{
    user_feed_item_id: string;
    state: string;
  }>(`/my-feed/items/${id}/skip`, { method: 'POST', body: JSON.stringify({}) });
  return response.data;
}

export { ApiRequestError };
