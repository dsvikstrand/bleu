import { useMemo, useState, useEffect } from 'react';
import { Link, useSearchParams } from 'react-router-dom';
import { useQuery, useQueryClient, useMutation } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/contexts/AuthContext';
import { AppHeader } from '@/components/shared/AppHeader';
import { AppFooter } from '@/components/shared/AppFooter';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Card, CardContent } from '@/components/ui/card';
import { Skeleton } from '@/components/ui/skeleton';
import { Tabs, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Tag, Layers, ChevronsUpDown, Check, Sparkles, Grid3X3, Users } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { usePopularInventoryTags } from '@/hooks/usePopularInventoryTags';
import { useTagFollows } from '@/hooks/useTagFollows';
import type { Json } from '@/integrations/supabase/types';
import { buildFeedSummary } from '@/lib/feedPreview';
import { formatRelativeShort } from '@/lib/timeFormat';
import { matchesChannelByTags, resolveChannelLabelForBlueprint } from '@/lib/channelMapping';
import { normalizeTag } from '@/lib/tagging';
import { CHANNELS_CATALOG } from '@/lib/channelsCatalog';
import { logOncePerSession, logP3Event } from '@/lib/telemetry';
import { getChannelIcon } from '@/lib/channelIcons';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Command, CommandEmpty, CommandGroup, CommandInput, CommandItem, CommandList } from '@/components/ui/command';
import { Sheet, SheetContent, SheetDescription, SheetHeader, SheetTitle, SheetTrigger } from '@/components/ui/sheet';
import { cn } from '@/lib/utils';
import { useIsMobile } from '@/hooks/use-mobile';
import { useMyFeed } from '@/hooks/useMyFeed';
import { extractYouTubeVideoId } from '@/lib/sourceIdentity';
import { ApiRequestError } from '@/lib/subscriptionsApi';
import { unlockSourcePageVideos } from '@/lib/sourcePagesApi';
import { WallBlueprintCard } from '@/components/wall/WallBlueprintCard';
import { ForYouLockedSourceCard } from '@/components/wall/ForYouLockedSourceCard';
import { UnlockActivityCard } from '@/components/shared/UnlockActivityCard';
import { useSourceUnlockJobTracker } from '@/hooks/useSourceUnlockJobTracker';

interface BlueprintPost {
  id: string;
  creator_user_id: string;
  title: string;
  selected_items: Json;
  llm_review: string | null;
  banner_url: string | null;
  likes_count: number;
  created_at: string;
  profile: {
    display_name: string | null;
    avatar_url: string | null;
  };
  tags: { id: string; slug: string }[];
  user_liked: boolean;
  published_channel_slug?: string | null;
  source_channel_title?: string | null;
}

type ForYouLockedItem = {
  kind: 'locked';
  feedItemId: string;
  sourceItemId: string;
  createdAt: string;
  title: string;
  sourceChannelTitle: string | null;
  sourceUrl: string;
  unlockCost: number;
  sourcePageId: string | null;
  sourceChannelId: string | null;
  unlockInProgress: boolean;
};

type ForYouBlueprintItem = {
  kind: 'blueprint';
  feedItemId: string;
  sourceItemId: string;
  createdAt: string;
  blueprintId: string;
  title: string;
  sourceChannelTitle: string | null;
  llmReview: string | null;
  bannerUrl: string | null;
  tags: string[];
  publishedChannelSlug: string | null;
};

type ForYouStreamItem = ForYouLockedItem | ForYouBlueprintItem;

const SORT_TABS = [
  { value: 'latest', label: 'Latest' },
  { value: 'trending', label: 'Trending' },
] as const;

type FeedSort = (typeof SORT_TABS)[number]['value'];
type ForYouFilter = 'all' | 'locked' | 'open';

const SCOPE_FOR_YOU = 'for-you';
const SCOPE_YOUR_CHANNELS = 'your-channels';
const SCOPE_ALL = 'all';

function getForYouErrorMessage(error: unknown, fallback: string) {
  if (error instanceof ApiRequestError) {
    if (error.errorCode === 'INSUFFICIENT_CREDITS') {
      return 'Not enough credits to unlock this blueprint yet.';
    }
    if (error.errorCode === 'RATE_LIMITED') {
      return 'Too many unlock requests, retry shortly.';
    }
    if (error.errorCode === 'SOURCE_PAGE_NOT_FOUND') {
      return 'Source page missing for this item. Try opening the source first.';
    }
    return error.message || fallback;
  }
  if (error instanceof Error && /source video id/i.test(error.message)) {
    return 'Could not resolve source video id for this item. Try opening it from Source Page.';
  }
  return error instanceof Error ? error.message : fallback;
}

export default function Wall() {
  const { user, isLoading: authLoading } = useAuth();
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const isMobile = useIsMobile();
  const [searchParams, setSearchParams] = useSearchParams();
  const [scopeOpen, setScopeOpen] = useState(false);
  const [selectedTagSlug, setSelectedTagSlug] = useState<string | null>(null);
  const [showScopeHelper, setShowScopeHelper] = useState(false);
  const [optimisticUnlockingSourceItemIds, setOptimisticUnlockingSourceItemIds] = useState<Record<string, boolean>>({});
  const { followedTags } = useTagFollows();

  const joinedChannelSlugs = useMemo(() => {
    if (!user) return null;
    const followedTagSlugs = new Set(followedTags.map((tag) => normalizeTag(tag.slug)));
    return new Set(
      CHANNELS_CATALOG
        .filter((channel) => channel.status === 'active' && followedTagSlugs.has(normalizeTag(channel.tagSlug)))
        .map((channel) => channel.slug),
    );
  }, [followedTags, user]);

  const scopeOptions = useMemo(() => {
    const base = user
      ? [
          {
            value: SCOPE_FOR_YOU,
            label: 'For You',
            icon: Sparkles,
          },
          {
            value: SCOPE_YOUR_CHANNELS,
            label: 'Your channels',
            icon: Users,
          },
        ]
      : [];

    const allOption = {
      value: SCOPE_ALL,
      label: 'Show all',
      icon: Grid3X3,
    };

    const channelOptions = CHANNELS_CATALOG
      .filter((channel) => {
        if (channel.status !== 'active') return false;
        if (!user || !joinedChannelSlugs) return true;
        return joinedChannelSlugs.has(channel.slug);
      })
      .sort((a, b) => a.priority - b.priority)
      .map((channel) => ({
        value: channel.slug,
        label: `b/${channel.slug}`,
        icon: getChannelIcon(channel.icon),
        channel,
      }));

    return [...base, allOption, ...channelOptions];
  }, [joinedChannelSlugs, user]);

  const scopeValues = useMemo(() => new Set(scopeOptions.map((option) => option.value)), [scopeOptions]);
  const scopeParam = (searchParams.get('scope') || '').trim();
  const sortParam = (searchParams.get('sort') || '').trim();
  const forYouFilterParam = (searchParams.get('state') || '').trim();
  const defaultScope = user ? SCOPE_FOR_YOU : SCOPE_ALL;
  const feedScope = scopeValues.has(scopeParam) ? scopeParam : defaultScope;
  const requestedSort: FeedSort = sortParam === 'trending' ? 'trending' : 'latest';

  const isPersonalScope = feedScope === SCOPE_FOR_YOU || feedScope === SCOPE_YOUR_CHANNELS;
  const effectiveScope = !user && isPersonalScope ? SCOPE_ALL : feedScope;
  const isForYouScope = effectiveScope === SCOPE_FOR_YOU && !!user;
  const isYourChannelsScope = effectiveScope === SCOPE_YOUR_CHANNELS && !!user;
  const feedSort: FeedSort = isForYouScope ? 'latest' : requestedSort;
  const forYouFilter: ForYouFilter = forYouFilterParam === 'locked' || forYouFilterParam === 'open'
    ? forYouFilterParam
    : 'all';

  useEffect(() => {
    if (!user) {
      setShowScopeHelper(false);
      return;
    }
    const dismissed = localStorage.getItem('home_scope_helper_dismissed_v1') === '1';
    setShowScopeHelper(!dismissed);
  }, [user?.id, user]);

  const updateSearchParams = (updates: { scope?: string; sort?: FeedSort; state?: ForYouFilter | null }) => {
    const next = new URLSearchParams(searchParams);
    if (updates.scope) next.set('scope', updates.scope);
    if (updates.sort) next.set('sort', updates.sort);
    if (updates.state === null) next.delete('state');
    else if (updates.state) next.set('state', updates.state);
    setSearchParams(next, { replace: true });
  };

  const dismissScopeHelper = () => {
    localStorage.setItem('home_scope_helper_dismissed_v1', '1');
    setShowScopeHelper(false);
  };

  useEffect(() => {
    if (!isForYouScope || requestedSort !== 'trending') return;
    updateSearchParams({ sort: 'latest' });
  }, [isForYouScope, requestedSort]);

  const handleScopeSelect = (scope: string) => {
    const nextSort = scope === SCOPE_FOR_YOU ? 'latest' : feedSort;
    updateSearchParams({
      scope,
      sort: nextSort,
      state: scope === SCOPE_FOR_YOU ? forYouFilter : null,
    });
    setScopeOpen(false);

    logP3Event({
      eventName: 'wall_scope_selected',
      surface: 'wall',
      user,
      metadata: {
        scope,
      },
    });
  };

  const { data: popularTags = [] } = usePopularInventoryTags(6);

  const curatedJoinableSlugs = useMemo(
    () =>
      new Set(
        CHANNELS_CATALOG
          .filter((channel) => channel.isJoinEnabled && channel.status === 'active')
          .map((channel) => channel.tagSlug),
      ),
    [],
  );

  const joinedCuratedCount = useMemo(() => {
    return followedTags.filter((tag) => curatedJoinableSlugs.has(normalizeTag(tag.slug))).length;
  }, [curatedJoinableSlugs, followedTags]);

  const handleTagFilter = (tagSlug: string) => {
    setSelectedTagSlug((current) => {
      const next = current === tagSlug ? null : tagSlug;
      if (next) {
        logP3Event({
          eventName: 'wall_tag_filter_used',
          surface: 'wall',
          user,
          metadata: {
            tab: effectiveScope,
            tag_slug: normalizeTag(next),
          },
        });
      }
      return next;
    });
  };

  const wallQueryKey = ['wall-blueprints', effectiveScope, feedSort, user?.id] as const;

  const { data: posts, isLoading: isBlueprintFeedLoading, error: blueprintFeedError } = useQuery({
    queryKey: wallQueryKey,
    enabled: !isForYouScope,
    queryFn: async () => {
      const scopedChannel =
        effectiveScope !== SCOPE_ALL && effectiveScope !== SCOPE_FOR_YOU && effectiveScope !== SCOPE_YOUR_CHANNELS
          ? CHANNELS_CATALOG.find((channel) => channel.slug === effectiveScope)
          : null;
      const isSpecificChannelScope = !!scopedChannel;

      const limit = isYourChannelsScope || isSpecificChannelScope ? 140 : 90;
      let query = supabase
        .from('blueprints')
        .select('id, creator_user_id, title, selected_items, llm_review, banner_url, likes_count, created_at')
        .eq('is_public', true)
        .limit(limit);

      if (feedSort === 'trending') {
        const cutoff = new Date();
        cutoff.setDate(cutoff.getDate() - 3);
        query = query
          .gte('created_at', cutoff.toISOString())
          .order('likes_count', { ascending: false })
          .order('created_at', { ascending: false });
      } else {
        query = query.order('created_at', { ascending: false });
      }

      const { data: blueprints, error } = await query;
      if (error) throw error;
      if (!blueprints || blueprints.length === 0) return [] as BlueprintPost[];

      const blueprintIds = blueprints.map((row) => row.id);
      const userIds = [...new Set(blueprints.map((row) => row.creator_user_id))];

      const [tagsRes, likesRes, profilesRes, feedItemsRes] = await Promise.all([
        supabase.from('blueprint_tags').select('blueprint_id, tag_id').in('blueprint_id', blueprintIds),
        user
          ? supabase.from('blueprint_likes').select('blueprint_id').eq('user_id', user.id).in('blueprint_id', blueprintIds)
          : Promise.resolve({ data: [] as { blueprint_id: string }[] }),
        supabase.from('profiles').select('user_id, display_name, avatar_url').in('user_id', userIds),
        supabase
          .from('user_feed_items')
          .select('id, blueprint_id, source_item_id, created_at')
          .in('blueprint_id', blueprintIds),
      ]);

      const tagRows = tagsRes.data || [];
      const tagIds = [...new Set(tagRows.map((row) => row.tag_id))];
      const { data: tagsData } = tagIds.length > 0
        ? await supabase.from('tags').select('id, slug').in('id', tagIds)
        : { data: [] as { id: string; slug: string }[] };

      const tagsMap = new Map((tagsData || []).map((tag) => [tag.id, tag]));
      const blueprintTags = new Map<string, { id: string; slug: string }[]>();

      tagRows.forEach((row) => {
        const tag = tagsMap.get(row.tag_id);
        if (!tag) return;
        const list = blueprintTags.get(row.blueprint_id) || [];
        list.push(tag);
        blueprintTags.set(row.blueprint_id, list);
      });

      const likedIds = new Set((likesRes.data || []).map((row) => row.blueprint_id));
      const profilesMap = new Map((profilesRes.data || []).map((profile) => [profile.user_id, profile]));
      if (feedItemsRes.error) throw feedItemsRes.error;

      const publishedChannelByBlueprint = new Map<string, { slug: string; createdAtMs: number }>();
      const sourceChannelTitleByBlueprint = new Map<string, { title: string | null; createdAtMs: number }>();
      const feedItems = (feedItemsRes.data || []) as Array<{ id: string; blueprint_id: string; source_item_id: string; created_at: string }>;
      const feedItemIds = feedItems.map((row) => row.id);
      const blueprintIdByFeedItemId = new Map(feedItems.map((row) => [row.id, row.blueprint_id]));
      const sourceItemIds = [...new Set(feedItems.map((row) => String(row.source_item_id || '').trim()).filter(Boolean))];

      const { data: sourceItemsData, error: sourceItemsError } = sourceItemIds.length > 0
        ? await supabase
          .from('source_items')
          .select('id, source_channel_title, metadata')
          .in('id', sourceItemIds)
        : { data: [], error: null };
      if (sourceItemsError) throw sourceItemsError;

      const sourceItemsMap = new Map(
        (sourceItemsData || []).map((row) => {
          const metadata =
            row.metadata && typeof row.metadata === 'object' && row.metadata !== null
              ? (row.metadata as Record<string, unknown>)
              : null;
          const metadataSourceTitle =
            metadata && typeof metadata.source_channel_title === 'string'
              ? String(metadata.source_channel_title || '').trim() || null
              : (
                metadata && typeof metadata.channel_title === 'string'
                  ? String(metadata.channel_title || '').trim() || null
                  : null
              );
          return [row.id, row.source_channel_title || metadataSourceTitle || null] as const;
        }),
      );
      let publishedCandidateRows: Array<{
        channel_slug: string;
        created_at: string;
        user_feed_item_id: string;
      }> = [];

      if (feedItemIds.length > 0) {
        const { data: candidatesData, error: candidatesError } = await supabase
          .from('channel_candidates')
          .select('channel_slug, created_at, user_feed_item_id')
          .eq('status', 'published')
          .in('user_feed_item_id', feedItemIds);
        if (candidatesError) throw candidatesError;
        publishedCandidateRows = (candidatesData || []) as Array<{
          channel_slug: string;
          created_at: string;
          user_feed_item_id: string;
        }>;
      }

      for (const row of publishedCandidateRows) {
        const blueprintId = blueprintIdByFeedItemId.get(row.user_feed_item_id);
        const channelSlug = String(row.channel_slug || '').trim().toLowerCase();
        if (!blueprintId || !channelSlug) continue;

        const createdAtMs = Number.isFinite(Date.parse(row.created_at)) ? Date.parse(row.created_at) : 0;
        const existing = publishedChannelByBlueprint.get(blueprintId);
        if (!existing || createdAtMs > existing.createdAtMs || (createdAtMs === existing.createdAtMs && channelSlug < existing.slug)) {
          publishedChannelByBlueprint.set(blueprintId, { slug: channelSlug, createdAtMs });
        }
      }

      for (const row of feedItems) {
        const blueprintId = row.blueprint_id;
        const sourceTitle = sourceItemsMap.get(row.source_item_id) || null;
        const createdAtMs = Number.isFinite(Date.parse(row.created_at)) ? Date.parse(row.created_at) : 0;
        const existing = sourceChannelTitleByBlueprint.get(blueprintId);
        if (!existing || createdAtMs > existing.createdAtMs) {
          sourceChannelTitleByBlueprint.set(blueprintId, { title: sourceTitle, createdAtMs });
        }
      }

      let followTagIds = new Set<string>();
      if (isYourChannelsScope && user) {
        const followsRes = await supabase.from('tag_follows').select('tag_id').eq('user_id', user.id);
        followTagIds = new Set((followsRes.data || []).map((row) => row.tag_id));
      }

      const hydrated = blueprints.map((blueprint) => ({
        ...blueprint,
        profile: profilesMap.get(blueprint.creator_user_id) || { display_name: null, avatar_url: null },
        tags: blueprintTags.get(blueprint.id) || [],
        user_liked: likedIds.has(blueprint.id),
        published_channel_slug: publishedChannelByBlueprint.get(blueprint.id)?.slug || null,
        source_channel_title: sourceChannelTitleByBlueprint.get(blueprint.id)?.title || null,
      })) as BlueprintPost[];

      if (isSpecificChannelScope && scopedChannel) {
        return hydrated.filter((post) => {
          if (post.published_channel_slug) {
            return post.published_channel_slug === scopedChannel.slug;
          }
          return matchesChannelByTags(scopedChannel.slug, post.tags.map((tag) => tag.slug));
        });
      }

      if (isYourChannelsScope) {
        if (followTagIds.size === 0) return hydrated;

        const joinedChannelPosts: BlueprintPost[] = [];
        const globalFillPosts: BlueprintPost[] = [];

        hydrated.forEach((post) => {
          if (post.tags.some((tag) => followTagIds.has(tag.id))) {
            joinedChannelPosts.push(post);
          } else {
            globalFillPosts.push(post);
          }
        });

        return [...joinedChannelPosts, ...globalFillPosts];
      }

      return hydrated;
    },
  });

  const postIds = useMemo(() => (posts || []).map((post) => post.id), [posts]);

  const { data: commentCountsByBlueprintId = {} } = useQuery({
    queryKey: ['wall-blueprint-comment-counts', postIds],
    enabled: !isForYouScope && postIds.length > 0,
    staleTime: 30_000,
    queryFn: async () => {
      const { data, error } = await supabase
        .from('blueprint_comments')
        .select('blueprint_id')
        .in('blueprint_id', postIds);

      if (error) throw error;

      return (data || []).reduce<Record<string, number>>((acc, row) => {
        acc[row.blueprint_id] = (acc[row.blueprint_id] || 0) + 1;
        return acc;
      }, {});
    },
  });

  const myFeedQuery = useMyFeed({ enabled: isForYouScope });

  const forYouSubscriptionsQuery = useQuery({
    queryKey: ['wall-for-you-subscriptions', user?.id],
    enabled: isForYouScope && !!user,
    queryFn: async () => {
      if (!user) return [] as Array<{ source_page_id: string | null; source_channel_id: string | null }>;
      const { data, error } = await supabase
        .from('user_source_subscriptions')
        .select('source_page_id, source_channel_id')
        .eq('user_id', user.id)
        .eq('is_active', true);
      if (error) throw error;
      return (data || []) as Array<{ source_page_id: string | null; source_channel_id: string | null }>;
    },
  });

  const forYouStream = useMemo(() => {
    if (!isForYouScope || !myFeedQuery.data || !forYouSubscriptionsQuery.data) return [] as ForYouStreamItem[];

    const activeSourcePageIds = new Set(
      forYouSubscriptionsQuery.data
        .map((row) => String(row.source_page_id || '').trim())
        .filter(Boolean),
    );
    const activeSourceChannelIds = new Set(
      forYouSubscriptionsQuery.data
        .map((row) => String(row.source_channel_id || '').trim())
        .filter(Boolean),
    );

    const items: ForYouStreamItem[] = [];

    myFeedQuery.data.forEach((item) => {
      if (!item.source) return;
      if (item.state === 'subscription_notice') return;

      const sourcePageId = String(item.source.sourcePageId || '').trim();
      const sourceChannelId = String(item.source.sourceChannelId || '').trim();
      const isSubscribedSource =
        (sourcePageId && activeSourcePageIds.has(sourcePageId))
        || (sourceChannelId && activeSourceChannelIds.has(sourceChannelId));

      if (!isSubscribedSource) return;

      if (item.blueprint) {
        items.push({
          kind: 'blueprint',
          feedItemId: item.id,
          sourceItemId: item.source.id,
          createdAt: item.createdAt,
          blueprintId: item.blueprint.id,
          title: item.blueprint.title,
          sourceChannelTitle: item.source.sourceChannelTitle || null,
          llmReview: item.blueprint.llmReview,
          bannerUrl: item.blueprint.bannerUrl,
          tags: item.blueprint.tags,
          publishedChannelSlug: item.candidate?.status === 'published' ? item.candidate.channelSlug : null,
        });
        return;
      }

      items.push({
        kind: 'locked',
        feedItemId: item.id,
        sourceItemId: item.source.id,
        createdAt: item.createdAt,
        title: item.source.title,
        sourceChannelTitle: item.source.sourceChannelTitle,
        sourceUrl: item.source.sourceUrl,
        unlockCost: Number(item.source.unlockCost || 0),
        sourcePageId: item.source.sourcePageId,
        sourceChannelId: item.source.sourceChannelId,
        unlockInProgress: Boolean(item.source.unlockInProgress) || Boolean(optimisticUnlockingSourceItemIds[item.source.id]),
      });
    });

    return items;
  }, [isForYouScope, myFeedQuery.data, forYouSubscriptionsQuery.data, optimisticUnlockingSourceItemIds]);

  const forYouBlueprintIds = useMemo(
    () => forYouStream.filter((item): item is ForYouBlueprintItem => item.kind === 'blueprint').map((item) => item.blueprintId),
    [forYouStream],
  );

  const forYouStatsQuery = useQuery({
    queryKey: ['wall-for-you-blueprint-stats', user?.id, forYouBlueprintIds],
    enabled: isForYouScope && !!user && forYouBlueprintIds.length > 0,
    queryFn: async () => {
      const [{ data: blueprintRows, error: blueprintError }, { data: likedRows, error: likedError }, { data: commentRows, error: commentError }] = await Promise.all([
        supabase
          .from('blueprints')
          .select('id, likes_count')
          .in('id', forYouBlueprintIds),
        supabase
          .from('blueprint_likes')
          .select('blueprint_id')
          .eq('user_id', user!.id)
          .in('blueprint_id', forYouBlueprintIds),
        supabase
          .from('blueprint_comments')
          .select('blueprint_id')
          .in('blueprint_id', forYouBlueprintIds),
      ]);

      if (blueprintError) throw blueprintError;
      if (likedError) throw likedError;
      if (commentError) throw commentError;

      const likes = (blueprintRows || []).reduce<Record<string, number>>((acc, row) => {
        acc[row.id] = Number(row.likes_count || 0);
        return acc;
      }, {});

      const likedIds = new Set((likedRows || []).map((row) => row.blueprint_id));
      const comments = (commentRows || []).reduce<Record<string, number>>((acc, row) => {
        acc[row.blueprint_id] = (acc[row.blueprint_id] || 0) + 1;
        return acc;
      }, {});

      return {
        likes,
        likedIds,
        comments,
      };
    },
  });

  const likeMutation = useMutation({
    mutationFn: async ({ blueprintId, liked }: { blueprintId: string; liked: boolean }) => {
      if (!user) throw new Error('Must be logged in');

      if (liked) {
        await supabase.from('blueprint_likes').delete().eq('blueprint_id', blueprintId).eq('user_id', user.id);
      } else {
        await supabase.from('blueprint_likes').insert({ blueprint_id: blueprintId, user_id: user.id });
      }
    },
    onSuccess: async () => {
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: ['wall-blueprints'] }),
        queryClient.invalidateQueries({ queryKey: ['wall-for-you-blueprint-stats'] }),
      ]);
    },
    onError: () => {
      toast({
        title: 'Error',
        description: 'Failed to update like. Please try again.',
        variant: 'destructive',
      });
    },
  });

  const forYouUnlockTracker = useSourceUnlockJobTracker({
    userId: user?.id,
    enabled: Boolean(user) && isForYouScope,
    scope: 'source_item_unlock_generation',
    onTerminal: (job) => {
      setOptimisticUnlockingSourceItemIds({});
      void Promise.all([
        queryClient.invalidateQueries({ queryKey: ['my-feed-items', user?.id] }),
        queryClient.invalidateQueries({ queryKey: ['wall-blueprints'] }),
        queryClient.invalidateQueries({ queryKey: ['wall-for-you-blueprint-stats'] }),
        queryClient.invalidateQueries({ queryKey: ['ai-credits'] }),
        queryClient.refetchQueries({ queryKey: ['ai-credits'], exact: false }),
      ]);

      if (job.status === 'succeeded') {
        toast({
          title: 'Unlock complete',
          description: `Inserted ${job.inserted_count}, skipped ${job.skipped_count}, failed ${Math.max(0, job.processed_count - job.inserted_count - job.skipped_count)}.`,
        });
        return;
      }

      toast({
        title: 'Unlock failed',
        description: job.error_message || 'Could not complete unlock generation.',
        variant: 'destructive',
      });
    },
  });

  useEffect(() => {
    if (!isForYouScope || !user) return;
    void forYouUnlockTracker.resume();
  }, [forYouUnlockTracker.resume, isForYouScope, user]);

  const unlockMutation = useMutation({
    mutationFn: async (item: ForYouLockedItem) => {
      // Source-page API path key expects provider external id (YouTube channel id), not source_pages UUID.
      const externalId = String(item.sourceChannelId || '').trim();
      if (!externalId) {
        throw new Error('Could not resolve source channel for unlock.');
      }

      const sourceUrl = String(item.sourceUrl || '').trim();
      const videoId = extractYouTubeVideoId(sourceUrl);
      if (!videoId) {
        throw new Error('Could not resolve source video id.');
      }

      return unlockSourcePageVideos({
        platform: 'youtube',
        externalId,
        items: [{
          video_id: videoId,
          video_url: sourceUrl,
          title: item.title,
        }],
      });
    },
    onMutate: async (item) => {
      setOptimisticUnlockingSourceItemIds((current) => ({
        ...current,
        [item.sourceItemId]: true,
      }));

      logP3Event({
        eventName: 'wall_for_you_unlock_click',
        surface: 'wall',
        user,
        metadata: {
          source_item_id: item.sourceItemId,
        },
      });
    },
    onSuccess: async (result, item) => {
      if (result.job_id) {
        forYouUnlockTracker.start(result.job_id);
        logP3Event({
          eventName: 'wall_for_you_unlock_queued',
          surface: 'wall',
          user,
          metadata: {
            source_item_id: item.sourceItemId,
            job_id: result.job_id,
            queued_count: result.queued_count,
          },
        });
      } else {
        setOptimisticUnlockingSourceItemIds((current) => {
          const next = { ...current };
          delete next[item.sourceItemId];
          return next;
        });
      }

      toast({
        title: result.job_id ? 'Unlock queued' : 'No unlock queued',
        description: result.job_id
          ? `Queued ${result.queued_count} item${result.queued_count === 1 ? '' : 's'} for generation.`
          : `No new unlock started. Ready ${result.ready_count}, in progress ${result.in_progress_count}.`,
      });

      await Promise.all([
        queryClient.invalidateQueries({ queryKey: ['ai-credits'] }),
        queryClient.invalidateQueries({ queryKey: ['my-feed-items', user?.id] }),
        queryClient.invalidateQueries({ queryKey: ['wall-blueprints'] }),
      ]);
    },
    onError: (error, item) => {
      setOptimisticUnlockingSourceItemIds((current) => {
        const next = { ...current };
        delete next[item.sourceItemId];
        return next;
      });

      logP3Event({
        eventName: 'wall_for_you_unlock_failed',
        surface: 'wall',
        user,
        metadata: {
          source_item_id: item.sourceItemId,
          error: error instanceof Error ? error.message : 'unknown',
        },
      });

      toast({
        title: 'Unlock failed',
        description: getForYouErrorMessage(error, 'Could not start unlock.'),
        variant: 'destructive',
      });
    },
    onSettled: async () => {
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: ['ai-credits'] }),
        queryClient.refetchQueries({ queryKey: ['ai-credits'], exact: false }),
      ]);
    },
  });

  const handleLike = (blueprintId: string, currentlyLiked: boolean) => {
    if (!user) {
      toast({
        title: 'Sign in required',
        description: 'Please sign in to like blueprints.',
      });
      return;
    }
    likeMutation.mutate({ blueprintId, liked: currentlyLiked });
  };

  const showZeroJoinYourChannelsCta = !!user && isYourChannelsScope && joinedCuratedCount === 0;

  const filteredForYouStream = useMemo(() => {
    if (!isForYouScope) return forYouStream;
    if (forYouFilter === 'locked') return forYouStream.filter((item) => item.kind === 'locked');
    if (forYouFilter === 'open') return forYouStream.filter((item) => item.kind === 'blueprint');
    return forYouStream;
  }, [forYouFilter, forYouStream, isForYouScope]);

  useEffect(() => {
    if (!showZeroJoinYourChannelsCta) return;
    logOncePerSession('p3_wall_zero_join_cta_impression', () => {
      logP3Event({
        eventName: 'wall_zero_join_cta_impression',
        surface: 'wall',
        user,
        metadata: {
          tab: effectiveScope,
          joined_channels_count: 0,
        },
      });
    });
  }, [effectiveScope, showZeroJoinYourChannelsCta, user]);

  const visiblePosts = useMemo(() => {
    if (!posts) return [];
    if (!selectedTagSlug) return posts;
    return posts.filter((post) => post.tags.some((tag) => tag.slug === selectedTagSlug));
  }, [posts, selectedTagSlug]);

  const selectedScope = useMemo(() => {
    return scopeOptions.find((option) => option.value === effectiveScope) || scopeOptions[0];
  }, [effectiveScope, scopeOptions]);

  const isForYouLoading = isForYouScope && (myFeedQuery.isLoading || forYouSubscriptionsQuery.isLoading);
  const isForYouError = isForYouScope && (myFeedQuery.isError || forYouSubscriptionsQuery.isError || forYouStatsQuery.isError);

  if (authLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin h-8 w-8 border-4 border-primary border-t-transparent rounded-full" />
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-background">
      <AppHeader />

      <main className="max-w-3xl mx-auto px-0 pb-24">
        <section className="mb-6 px-3 sm:px-4">
          <div className="flex flex-col gap-2">
            <p className="text-sm font-semibold text-primary uppercase tracking-wide">Home</p>
            <h1 className="text-2xl font-semibold">Live blueprint stream</h1>
            <p className="text-sm text-muted-foreground">
              For You is your subscribed-source stream (locked + open). Your channels is your followed-channel lane (latest/trending).
            </p>
          </div>
        </section>

        {user && showScopeHelper ? (
          <div className="mb-4 mx-3 sm:mx-4 border border-border/40 px-3 py-3">
            <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
              <p className="text-xs text-muted-foreground">
                Tip: use <span className="font-medium text-foreground">For You</span> to unlock source videos directly, and <span className="font-medium text-foreground">Your channels</span> to browse followed channels.
              </p>
              <Button size="sm" variant="ghost" className="h-7 px-2.5 text-xs" onClick={dismissScopeHelper}>
                Dismiss
              </Button>
            </div>
          </div>
        ) : null}

        {!user && (
          <div className="mb-6 mx-3 sm:mx-4 border border-border/40 px-3 py-4">
            <div className="flex flex-col gap-2 text-center">
              <p className="text-sm font-semibold">Sign in to personalize</p>
              <p className="text-sm text-muted-foreground">
                Join channels to shape your feed, then follow creators you trust.
              </p>
              <div className="flex justify-center">
                <Link to="/auth">
                  <Button size="sm">Sign in</Button>
                </Link>
              </div>
            </div>
          </div>
        )}

        <div className="space-y-3">
          <div className="px-3 sm:px-4 flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
            {isMobile ? (
              <Sheet open={scopeOpen} onOpenChange={setScopeOpen}>
                <SheetTrigger asChild>
                  <Button variant="outline" size="sm" role="combobox" className="w-full justify-between">
                    <span className="inline-flex items-center gap-2 truncate">
                      {selectedScope?.icon && <selectedScope.icon className="h-4 w-4 shrink-0" />}
                      <span className="truncate">{selectedScope?.label || 'Select scope'}</span>
                    </span>
                    <ChevronsUpDown className="h-4 w-4 shrink-0 opacity-60" />
                  </Button>
                </SheetTrigger>
                <SheetContent side="bottom" className="h-[72vh] overflow-hidden px-0">
                  <SheetHeader className="px-4 pb-2">
                    <SheetTitle>Choose Home scope</SheetTitle>
                    <SheetDescription>Select which lane you want to browse.</SheetDescription>
                  </SheetHeader>
                  <div className="px-4 pb-4">
                    <Command className="rounded-lg border">
                      <CommandInput placeholder="Search scopes..." />
                      <CommandList className="max-h-[54vh]">
                        <CommandEmpty>No scopes found.</CommandEmpty>
                        <CommandGroup>
                          {scopeOptions.map((option) => (
                            <CommandItem
                              key={option.value}
                              value={`${option.label} ${option.value}`}
                              onSelect={() => handleScopeSelect(option.value)}
                              className="flex items-center gap-2"
                            >
                              <option.icon className="h-4 w-4 text-muted-foreground" />
                              <span className="truncate">{option.label}</span>
                              <Check
                                className={cn(
                                  'ml-auto h-4 w-4',
                                  effectiveScope === option.value ? 'opacity-100' : 'opacity-0',
                                )}
                              />
                            </CommandItem>
                          ))}
                        </CommandGroup>
                      </CommandList>
                    </Command>
                  </div>
                </SheetContent>
              </Sheet>
            ) : (
              <Popover open={scopeOpen} onOpenChange={setScopeOpen}>
                <PopoverTrigger asChild>
                  <Button variant="outline" size="sm" role="combobox" className="w-full sm:w-72 justify-between">
                    <span className="inline-flex items-center gap-2 truncate">
                      {selectedScope?.icon && <selectedScope.icon className="h-4 w-4 shrink-0" />}
                      <span className="truncate">{selectedScope?.label || 'Select scope'}</span>
                    </span>
                    <ChevronsUpDown className="h-4 w-4 shrink-0 opacity-60" />
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-[320px] p-0" align="start" side="bottom" sideOffset={8} collisionPadding={12}>
                  <Command>
                    <CommandInput placeholder="Search scopes..." />
                    <CommandList>
                      <CommandEmpty>No scopes found.</CommandEmpty>
                      <CommandGroup>
                        {scopeOptions.map((option) => (
                          <CommandItem
                            key={option.value}
                            value={`${option.label} ${option.value}`}
                            onSelect={() => handleScopeSelect(option.value)}
                            className="flex items-center gap-2"
                          >
                            <option.icon className="h-4 w-4 text-muted-foreground" />
                            <span className="truncate">{option.label}</span>
                            <Check
                              className={cn(
                                'ml-auto h-4 w-4',
                                effectiveScope === option.value ? 'opacity-100' : 'opacity-0',
                              )}
                            />
                          </CommandItem>
                        ))}
                      </CommandGroup>
                    </CommandList>
                  </Command>
                </PopoverContent>
              </Popover>
            )}

            {isForYouScope ? (
              <Tabs value={forYouFilter} onValueChange={(value) => updateSearchParams({ state: value as ForYouFilter })}>
                <TabsList className="h-9 w-full sm:w-fit rounded-md bg-muted/40 p-0.5">
                  <TabsTrigger value="all" className="flex-1 sm:flex-none">All</TabsTrigger>
                  <TabsTrigger value="locked" className="flex-1 sm:flex-none">Locked</TabsTrigger>
                  <TabsTrigger value="open" className="flex-1 sm:flex-none">Open</TabsTrigger>
                </TabsList>
              </Tabs>
            ) : (
              <Tabs value={feedSort} onValueChange={(v) => updateSearchParams({ sort: v as FeedSort })}>
                <TabsList className="h-9 w-full sm:w-fit rounded-md bg-muted/40 p-0.5">
                  {SORT_TABS.map((tab) => (
                    <TabsTrigger key={tab.value} value={tab.value} className="flex-1 sm:flex-none">
                      {tab.label}
                    </TabsTrigger>
                  ))}
                </TabsList>
              </Tabs>
            )}
          </div>

          <div className="mt-0">
            {!isForYouScope && selectedTagSlug && (
              <div className="mb-3 mx-3 sm:mx-4 border border-border/40 px-3 py-2 flex items-center justify-between gap-2">
                <p className="text-xs text-muted-foreground">
                  Filtered by <span className="font-semibold text-foreground">{selectedTagSlug}</span>
                </p>
                <Button variant="ghost" size="sm" className="h-7 px-2 text-xs" onClick={() => setSelectedTagSlug(null)}>
                  Clear
                </Button>
              </div>
            )}

            {showZeroJoinYourChannelsCta && (
              <div className="mb-3 mx-3 sm:mx-4 border border-border/40 px-3 py-3 flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
                <div>
                  <p className="text-sm font-semibold">Join channels to shape this lane</p>
                  <p className="text-xs text-muted-foreground">
                    Follow channels to personalize this lane.
                  </p>
                </div>
                <Button asChild size="sm">
                  <Link
                    to="/channels"
                    onClick={() => {
                      logP3Event({
                        eventName: 'wall_zero_join_cta_click',
                        surface: 'wall',
                        user,
                        metadata: {
                          tab: effectiveScope,
                        },
                      });
                    }}
                  >
                    Explore Channels
                  </Link>
                </Button>
              </div>
            )}

            {isForYouScope && forYouUnlockTracker.activity.visible ? (
              <div className="mb-3 mx-3 sm:mx-4">
                <UnlockActivityCard
                  title="For You unlock"
                  activity={forYouUnlockTracker.activity}
                  onClear={!forYouUnlockTracker.activity.isActive ? forYouUnlockTracker.clear : undefined}
                />
              </div>
            ) : null}

            {isForYouScope ? (
              isForYouLoading ? (
                Array.from({ length: 3 }).map((_, i) => (
                  <div key={i} className="px-3 sm:px-4 py-4 border-t border-border/40 first:border-t-0">
                    <div className="space-y-2">
                      <Skeleton className="h-4 w-28" />
                      <Skeleton className="h-5 w-3/4" />
                      <Skeleton className="h-14 w-full" />
                    </div>
                  </div>
                ))
              ) : isForYouError ? (
                <Card className="mx-3 sm:mx-4">
                  <CardContent className="py-6 text-sm text-muted-foreground">
                    Could not load For You right now. Please refresh and try again.
                  </CardContent>
                </Card>
              ) : filteredForYouStream.length > 0 ? (
                <div className="divide-y divide-border/40">
                  {filteredForYouStream.map((item) => {
                    if (item.kind === 'locked') {
                      return (
                        <ForYouLockedSourceCard
                          key={item.sourceItemId}
                          title={item.title}
                          sourceChannelTitle={item.sourceChannelTitle}
                          createdAt={item.createdAt}
                          sourceUrl={item.sourceUrl}
                          unlockCost={item.unlockCost}
                          isUnlocking={item.unlockInProgress}
                          onUnlock={() => unlockMutation.mutate(item)}
                        />
                      );
                    }

                    const fallbackChannelSlug = resolveChannelLabelForBlueprint(item.tags).replace(/^b\//, '');
                    const channelSlug = item.publishedChannelSlug || fallbackChannelSlug;
                    const summary = buildFeedSummary({
                      primary: item.llmReview,
                      fallback: 'Open to view the full step-by-step guide.',
                      maxChars: 220,
                    });
                    const likesCount = forYouStatsQuery.data?.likes[item.blueprintId] || 0;
                    const userLiked = Boolean(forYouStatsQuery.data?.likedIds.has(item.blueprintId));
                    const commentsCount = forYouStatsQuery.data?.comments[item.blueprintId] || 0;

                    return (
                      <WallBlueprintCard
                        key={item.sourceItemId}
                        to={`/blueprint/${item.blueprintId}`}
                        title={item.title}
                        summary={summary}
                        sourceName={item.sourceChannelTitle}
                        bannerUrl={item.bannerUrl}
                        createdLabel={formatRelativeShort(item.createdAt)}
                        channelSlug={channelSlug}
                        likesCount={likesCount}
                        userLiked={userLiked}
                        commentsCount={commentsCount}
                        tags={item.tags.map((tag) => ({ key: tag, label: tag }))}
                        onLike={(event) => {
                          event.preventDefault();
                          handleLike(item.blueprintId, userLiked);
                        }}
                      />
                    );
                  })}
                </div>
              ) : (
                <Card className="mx-3 sm:mx-4 text-center py-12">
                  <CardContent>
                    <div className="flex flex-col items-center gap-4">
                      <div className="h-16 w-16 rounded-full bg-muted flex items-center justify-center">
                        <Tag className="h-8 w-8 text-muted-foreground" />
                      </div>
                      <div>
                        <h3 className="font-semibold">No source items yet</h3>
                        <p className="text-sm text-muted-foreground mt-1">
                          Subscribe to a source to unlock videos here.
                        </p>
                      </div>
                      <div className="flex gap-2">
                        <Button asChild size="sm">
                          <Link to="/subscriptions">Manage subscriptions</Link>
                        </Button>
                        <Button asChild size="sm" variant="outline">
                          <Link to="/channels">Explore Channels</Link>
                        </Button>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              )
            ) : isBlueprintFeedLoading ? (
              Array.from({ length: 3 }).map((_, i) => (
                <div key={i} className="px-3 sm:px-4 py-4 border-t border-border/40 first:border-t-0">
                  <div className="flex flex-row items-center gap-3 mb-3">
                    <Skeleton className="h-10 w-10 rounded-full" />
                    <div className="space-y-2">
                      <Skeleton className="h-4 w-24" />
                      <Skeleton className="h-3 w-16" />
                    </div>
                  </div>
                  <Skeleton className="h-20 w-full" />
                </div>
              ))
            ) : blueprintFeedError ? (
              <Card className="mx-3 sm:mx-4">
                <CardContent className="py-6 text-sm text-muted-foreground">
                  Could not load Home right now. Please refresh and try again.
                </CardContent>
              </Card>
            ) : visiblePosts.length > 0 ? (
              <div className="divide-y divide-border/40">
                {visiblePosts.map((post) => {
                  const preview = buildFeedSummary({
                    primary: post.llm_review,
                    fallback: 'Open to view the full step-by-step guide.',
                    maxChars: 220,
                  });
                  const fallbackChannelSlug = resolveChannelLabelForBlueprint(post.tags.map((tag) => tag.slug)).replace(/^b\//, '');
                  const channelSlug = post.published_channel_slug || fallbackChannelSlug;
                  const commentsCount = commentCountsByBlueprintId[post.id] || 0;

                  return (
                    <WallBlueprintCard
                      key={post.id}
                      to={`/blueprint/${post.id}`}
                      title={post.title}
                      summary={preview}
                      sourceName={post.source_channel_title || null}
                      bannerUrl={post.banner_url}
                      createdLabel={formatRelativeShort(post.created_at)}
                      channelSlug={channelSlug}
                      likesCount={post.likes_count}
                      userLiked={post.user_liked}
                      commentsCount={commentsCount}
                      tags={post.tags.map((tag) => ({ key: tag.id, label: tag.slug }))}
                      onLike={(event) => {
                        event.preventDefault();
                        handleLike(post.id, post.user_liked);
                      }}
                    />
                  );
                })}
              </div>
            ) : (
              <Card className="text-center py-12 mx-3 sm:mx-4">
                <CardContent>
                  <div className="flex flex-col items-center gap-4">
                    <div className="h-16 w-16 rounded-full bg-muted flex items-center justify-center">
                      {isYourChannelsScope ? (
                        <Tag className="h-8 w-8 text-muted-foreground" />
                      ) : (
                        <Layers className="h-8 w-8 text-muted-foreground" />
                      )}
                    </div>
                    <div>
                      <h3 className="font-semibold">
                        {isYourChannelsScope ? 'Personalize your channels lane' : 'No blueprints yet'}
                      </h3>
                      <p className="text-sm text-muted-foreground mt-1">
                        {isYourChannelsScope
                          ? 'Join channels to see prioritized blueprints here.'
                          : 'Be the first to share a blueprint.'}
                      </p>
                    </div>

                    {isYourChannelsScope && popularTags.length > 0 && (
                      <div className="space-y-3 w-full max-w-md">
                        {!user && (
                          <div className="flex flex-col items-center gap-2">
                            <p className="text-xs text-muted-foreground">
                              Sign in to join channels and personalize this feed.
                            </p>
                            <Link to="/auth">
                              <Button size="sm">Sign in</Button>
                            </Link>
                          </div>
                        )}
                        <p className="text-xs text-muted-foreground">Popular topics:</p>
                        <div className="flex flex-wrap justify-center gap-2">
                          {popularTags.map((tag) => (
                            <Badge
                              key={tag.id}
                              variant="secondary"
                              className="gap-1.5 bg-muted/40 text-muted-foreground border border-border/60 cursor-pointer hover:bg-muted/60"
                              onClick={() => handleTagFilter(tag.slug)}
                            >
                              {tag.slug}
                            </Badge>
                          ))}
                        </div>
                        <Button asChild variant="outline" size="sm">
                          <Link to="/channels">Join Channels</Link>
                        </Button>
                      </div>
                    )}

                    {!isYourChannelsScope && (
                      <div className="flex gap-2">
                        <Link to="/youtube">
                          <Button>Pull from YouTube</Button>
                        </Link>
                        <Link to="/channels">
                          <Button variant="outline">Explore Channels</Button>
                        </Link>
                      </div>
                    )}
                  </div>
                </CardContent>
              </Card>
            )}
          </div>
        </div>

        <AppFooter />
      </main>
    </div>
  );
}
