type Row = Record<string, any>;
type TablesState = Record<string, Row[]>;

type OrderRule = {
  field: string;
  ascending: boolean;
};

type FilterRule = (row: Row) => boolean;

function cloneRow<T extends Row>(row: T): T {
  return JSON.parse(JSON.stringify(row));
}

function projectRow(row: Row, selectColumns: string | null) {
  if (!selectColumns || selectColumns === '*') return cloneRow(row);
  const keys = selectColumns
    .split(',')
    .map((key) => key.trim())
    .filter(Boolean)
    .map((key) => key.split('(')[0]?.trim())
    .filter(Boolean);
  if (keys.length === 0) return cloneRow(row);
  const output: Row = {};
  for (const key of keys) {
    output[key] = row[key];
  }
  return output;
}

function makeError(message: string, code?: string) {
  return {
    message,
    code: code || 'MOCK_ERROR',
  };
}

class QueryBuilder {
  private tableName: string;
  private state: TablesState;
  private selectColumns: string | null = null;
  private orderRules: OrderRule[] = [];
  private limitCount: number | null = null;
  private filters: FilterRule[] = [];
  private mode: 'select' | 'insert' | 'update' = 'select';
  private insertPayload: Row[] = [];
  private updatePayload: Row | null = null;

  constructor(tableName: string, state: TablesState) {
    this.tableName = tableName;
    this.state = state;
  }

  select(columns?: string) {
    this.selectColumns = columns?.trim() || '*';
    return this;
  }

  insert(payload: Row | Row[]) {
    this.mode = 'insert';
    this.insertPayload = Array.isArray(payload) ? payload.map((row) => cloneRow(row)) : [cloneRow(payload)];
    return this;
  }

  update(values: Row) {
    this.mode = 'update';
    this.updatePayload = cloneRow(values);
    return this;
  }

  upsert(values: Row | Row[], options?: { onConflict?: string; ignoreDuplicates?: boolean }) {
    const table = this.getTable();
    const rows = Array.isArray(values) ? values : [values];
    const onConflict = String(options?.onConflict || '').trim();
    const nowIso = new Date().toISOString();

    for (const raw of rows) {
      const row = cloneRow(raw);
      if (!onConflict) {
        table.push({
          ...row,
          created_at: row.created_at || nowIso,
          updated_at: row.updated_at || nowIso,
        });
        continue;
      }

      const existing = table.find((candidate) => String(candidate[onConflict] || '') === String(row[onConflict] || ''));
      if (existing) {
        if (options?.ignoreDuplicates) continue;
        Object.assign(existing, row, { updated_at: nowIso });
        continue;
      }
      table.push({
        ...row,
        created_at: row.created_at || nowIso,
        updated_at: row.updated_at || nowIso,
      });
    }

    return Promise.resolve({ data: null, error: null });
  }

  eq(field: string, value: any) {
    this.filters.push((row) => row[field] === value);
    return this;
  }

  in(field: string, values: any[]) {
    const set = new Set(values || []);
    this.filters.push((row) => set.has(row[field]));
    return this;
  }

  not(field: string, operator: 'is', value: any) {
    if (operator === 'is') {
      this.filters.push((row) => row[field] !== value);
    }
    return this;
  }

  lt(field: string, value: any) {
    this.filters.push((row) => row[field] < value);
    return this;
  }

  order(field: string, options?: { ascending?: boolean }) {
    this.orderRules.push({
      field,
      ascending: options?.ascending !== false,
    });
    return this;
  }

  limit(value: number) {
    this.limitCount = Math.max(0, Math.floor(Number(value) || 0));
    return this;
  }

  async maybeSingle() {
    const result = await this.execute();
    if (result.error) return { data: null, error: result.error };
    const rows = result.data || [];
    return { data: rows[0] || null, error: null };
  }

  async single() {
    const result = await this.execute();
    if (result.error) return { data: null, error: result.error };
    const rows = result.data || [];
    if (rows.length === 0) {
      return { data: null, error: makeError(`No rows in ${this.tableName}`) };
    }
    return { data: rows[0], error: null };
  }

  private getTable() {
    if (!this.state[this.tableName]) {
      this.state[this.tableName] = [];
    }
    return this.state[this.tableName];
  }

  private applyFilters(rows: Row[]) {
    return rows.filter((row) => this.filters.every((rule) => rule(row)));
  }

  private applyOrder(rows: Row[]) {
    if (this.orderRules.length === 0) return rows;
    const ordered = [...rows];
    ordered.sort((left, right) => {
      for (const rule of this.orderRules) {
        const a = left[rule.field];
        const b = right[rule.field];
        if (a === b) continue;
        if (a == null) return rule.ascending ? -1 : 1;
        if (b == null) return rule.ascending ? 1 : -1;
        if (a < b) return rule.ascending ? -1 : 1;
        if (a > b) return rule.ascending ? 1 : -1;
      }
      return 0;
    });
    return ordered;
  }

  private applyLimit(rows: Row[]) {
    if (this.limitCount == null) return rows;
    return rows.slice(0, this.limitCount);
  }

  private ensureCreditLedgerUnique(rows: Row[]) {
    if (this.tableName !== 'credit_ledger') return null;
    for (const row of rows) {
      const key = String(row.idempotency_key || '').trim();
      if (!key) continue;
      const exists = this.getTable().some((candidate) => String(candidate.idempotency_key || '').trim() === key);
      if (exists) {
        return makeError('duplicate key value violates unique constraint', '23505');
      }
    }
    return null;
  }

  private async execute() {
    const table = this.getTable();
    const nowIso = new Date().toISOString();

    if (this.mode === 'insert') {
      const duplicateError = this.ensureCreditLedgerUnique(this.insertPayload);
      if (duplicateError) {
        return { data: null, error: duplicateError };
      }
      const inserted: Row[] = [];
      for (const payload of this.insertPayload) {
        const row: Row = {
          id: payload.id || `${this.tableName}_${table.length + inserted.length + 1}`,
          created_at: payload.created_at || nowIso,
          updated_at: payload.updated_at || nowIso,
          ...payload,
        };
        table.push(row);
        inserted.push(projectRow(row, this.selectColumns));
      }
      return { data: inserted, error: null };
    }

    if (this.mode === 'update') {
      const payload = this.updatePayload || {};
      const matched = this.applyFilters(table);
      const updated: Row[] = [];
      for (const row of matched) {
        Object.assign(row, payload);
        if (!Object.prototype.hasOwnProperty.call(payload, 'updated_at')) {
          row.updated_at = nowIso;
        }
        updated.push(projectRow(row, this.selectColumns));
      }
      const limited = this.applyLimit(this.applyOrder(updated));
      return { data: limited, error: null };
    }

    const selected = this.applyLimit(this.applyOrder(this.applyFilters(table))).map((row) => projectRow(row, this.selectColumns));
    return { data: selected, error: null };
  }
}

export function createMockSupabase(initialTables?: Partial<TablesState>) {
  const state: TablesState = {
    user_credit_wallets: [],
    credit_ledger: [],
    source_item_unlocks: [],
    ingestion_jobs: [],
    ...(initialTables || {}),
  };

  return {
    state,
    from(tableName: string) {
      return new QueryBuilder(tableName, state);
    },
  };
}

