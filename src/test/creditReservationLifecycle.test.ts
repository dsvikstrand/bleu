import { describe, expect, it } from 'vitest';
import { refundReservation, reserveCredits, settleReservation } from '../../server/services/creditWallet';
import { createMockSupabase } from './helpers/mockSupabase';

describe('credit reservation lifecycle', () => {
  it('keeps hold/settle/refund idempotent by idempotency key', async () => {
    const db = createMockSupabase({
      user_credit_wallets: [
        {
          user_id: 'user_1',
          balance: 10,
          capacity: 10,
          refill_rate_per_sec: 0,
          last_refill_at: '2026-02-20T10:00:00.000Z',
          created_at: '2026-02-20T10:00:00.000Z',
          updated_at: '2026-02-20T10:00:00.000Z',
        },
      ],
      credit_ledger: [],
    }) as any;

    const holdA = await reserveCredits(db, {
      userId: 'user_1',
      amount: 1,
      idempotencyKey: 'hold_unlock_1',
      reasonCode: 'UNLOCK_HOLD',
      context: {
        unlock_id: 'unlock_1',
        metadata: {
          trace_id: 'ut_credit_1',
        },
      },
    });
    expect(holdA.ok).toBe(true);

    const holdB = await reserveCredits(db, {
      userId: 'user_1',
      amount: 1,
      idempotencyKey: 'hold_unlock_1',
      reasonCode: 'UNLOCK_HOLD',
      context: {
        unlock_id: 'unlock_1',
      },
    });
    expect(holdB.ok).toBe(true);
    if (holdA.ok && holdB.ok) {
      expect(holdA.ledger_id).toBe(holdB.ledger_id);
      expect(holdB.wallet.balance).toBeCloseTo(9, 3);
    }

    const settleA = await settleReservation(db, {
      userId: 'user_1',
      amount: 1,
      idempotencyKey: 'settle_unlock_1',
      reasonCode: 'UNLOCK_SETTLE',
      context: {
        unlock_id: 'unlock_1',
      },
    });
    const settleB = await settleReservation(db, {
      userId: 'user_1',
      amount: 1,
      idempotencyKey: 'settle_unlock_1',
      reasonCode: 'UNLOCK_SETTLE',
      context: {
        unlock_id: 'unlock_1',
      },
    });
    expect(settleA.ledger_id).toBe(settleB.ledger_id);

    const refundA = await refundReservation(db, {
      userId: 'user_1',
      amount: 1,
      idempotencyKey: 'refund_unlock_1',
      reasonCode: 'UNLOCK_REFUND',
      context: {
        unlock_id: 'unlock_1',
      },
    });
    const balanceAfterRefundA = Number((refundA.wallet as { balance: number }).balance || 0);
    expect(balanceAfterRefundA).toBeCloseTo(10, 3);

    const refundB = await refundReservation(db, {
      userId: 'user_1',
      amount: 1,
      idempotencyKey: 'refund_unlock_1',
      reasonCode: 'UNLOCK_REFUND',
      context: {
        unlock_id: 'unlock_1',
      },
    });
    const balanceAfterRefundB = Number((refundB.wallet as { balance: number }).balance || 0);
    expect(balanceAfterRefundB).toBeCloseTo(10, 3);

    const holdRows = db.state.credit_ledger.filter((row: any) => row.entry_type === 'hold');
    const settleRows = db.state.credit_ledger.filter((row: any) => row.entry_type === 'settle');
    const refundRows = db.state.credit_ledger.filter((row: any) => row.entry_type === 'refund');
    expect(holdRows).toHaveLength(1);
    expect(settleRows).toHaveLength(1);
    expect(refundRows).toHaveLength(1);
    expect(holdRows[0]?.metadata?.trace_id).toBe('ut_credit_1');
  });
});

